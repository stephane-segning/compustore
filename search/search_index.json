{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Compustore Technical Project Guide","text":"<p>Author: [@stephane-segning] Audience: Development Team</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Project Infrastructure Setup</li> <li>User Stories and Product Backlog</li> <li>Development Environment Configuration</li> <li>Diagrams</li> </ol>"},{"location":"#1-project-infrastructure-setup","title":"1. Project Infrastructure Setup","text":"<p>Our priority is to establish a robust project infrastructure that supports a seamless development workflow, code quality, and continuous integration and deployment. The following steps outline how to set up our GitHub repository, CI/CD pipelines, and environment management for Compustore.</p>"},{"location":"#11-repository-creation-and-branching-strategy","title":"1.1 Repository Creation and Branching Strategy","text":"<ol> <li>GitHub Repository:</li> <li> <p>Initialize a private GitHub repository named <code>compustore</code>. Ensure it\u2019s accessible to all team members with required permissions.</p> </li> <li> <p>Branching Strategy:</p> </li> <li><code>main</code>: The production-ready branch. Only stable, thoroughly reviewed code gets merged here.</li> <li><code>develop</code>: For active development. All feature branches merge into <code>develop</code> post-review.</li> <li><code>feature/&lt;feature-name&gt;</code>: For individual features or tasks. Short-lived and merged into <code>develop</code> upon completion.</li> <li>Branch Protection: Protect both <code>main</code> and <code>develop</code> branches, requiring pull requests with reviews before merging.</li> </ol> <p>Diagram: Infrastructure Setup Workflow</p> <pre><code>flowchart TD\n    subgraph Infrastructure\n        A[Create GitHub Repo] --&gt; B[Define Branch Strategy]\n        B --&gt; C[Setup GitHub Actions CI/CD]\n        C --&gt; D[Configure Environment Variables]\n        D --&gt; E[Setup Dependabot]\n    end\n    A --&gt; F[Initialize Project Structure]</code></pre>"},{"location":"#12-cicd-pipeline-setup","title":"1.2 CI/CD Pipeline Setup","text":"<p>Objective: To automate testing, linting, and deployment.</p> <ol> <li>GitHub Actions (CI):</li> <li> <p>Create a <code>ci.yml</code> workflow file:</p> <ul> <li>Linting: Run ESLint and Prettier on each commit.</li> <li>Type Checking: Run TypeScript checks for consistency and type safety.</li> <li>Testing: Run all unit and integration tests, with coverage requirements enforced.</li> </ul> </li> <li> <p>GitHub Actions (CD):</p> </li> <li>Preview Builds on Vercel: Configure automatic deployments of preview builds for each pull request on Vercel.</li> <li> <p>Production Deployments: Any merge to <code>main</code> should automatically trigger a production deployment.</p> </li> <li> <p>Dependabot:</p> </li> <li>Enable Dependabot for dependency updates. It will raise pull requests when new versions of dependencies are available, reducing the likelihood of using outdated or vulnerable packages.</li> </ol>"},{"location":"#13-environment-variables-and-secrets","title":"1.3 Environment Variables and Secrets","text":"<p>Vercel will manage our environment variables securely. These variables ensure that sensitive information like API keys and database credentials remain secure. </p> Environment Variable Name Description Development <code>NEXT_PUBLIC_STRIPE_KEY</code> Stripe API key for development Staging <code>NEXT_PUBLIC_STRIPE_KEY</code> Stripe API key for staging Production <code>NEXT_PUBLIC_STRIPE_KEY</code> Stripe API key for production All Environments <code>DATABASE_URL</code> Neon.tech database URL All Environments <code>NEXTAUTH_SECRET</code> Secret for NextAuth encryption"},{"location":"#14-project-folder-structure","title":"1.4 Project Folder Structure","text":"<p>To maintain clarity and facilitate clean architecture, adhere to the following folder structure and naming conventions:</p> <pre><code>compustore/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/           # Reusable UI components\n\u2502   \u251c\u2500\u2500 pages/                # Next.js pages\n\u2502   \u251c\u2500\u2500 hooks/                # Custom React hooks\n\u2502   \u251c\u2500\u2500 utils/                # Utility functions\n\u2502   \u251c\u2500\u2500 styles/               # Global CSS and Tailwind styles\n\u2502   \u2514\u2500\u2500 lib/                  # Helper functions and library setup (e.g., Prisma, TRPC)\n\u251c\u2500\u2500 prisma/                   # Prisma schema and migrations\n\u251c\u2500\u2500 .github/\n\u2502   \u251c\u2500\u2500 workflows/            # GitHub Actions workflows for CI/CD\n\u2502   \u2514\u2500\u2500 dependabot.yml        # Dependabot configuration for automatic dependency updates\n\u251c\u2500\u2500 tests/                    # Test files for unit, integration, and E2E tests\n\u251c\u2500\u2500 .eslintrc.js              # ESLint configuration\n\u251c\u2500\u2500 .prettierrc               # Prettier configuration\n\u251c\u2500\u2500 next.config.js            # Next.js configuration\n\u2514\u2500\u2500 README.md                 # Project documentation\n</code></pre>"},{"location":"#2-user-stories-and-product-backlog","title":"2. User Stories and Product Backlog","text":""},{"location":"#21-user-stories","title":"2.1 User Stories","text":"<p>Each user story captures a requirement in terms of user functionality. These stories guide our development, ensuring that every feature delivers intended functionality and aligns with our security standards.</p>"},{"location":"#store-and-product-management","title":"Store and Product Management","text":"<ul> <li>Anonymous User: As an anonymous user, I want to browse products, so I can view available items before deciding to log in or purchase.</li> <li>Authenticated User: As a user, I want to add products to my cart, so I can purchase multiple items.</li> <li>Admin: As an admin, I want to manage product listings through an admin panel, so I can update and maintain the catalog.</li> </ul>"},{"location":"#authentication","title":"Authentication","text":"<ul> <li>Anonymous User: As an anonymous user, I want to log in using Google, Facebook, or GitHub, so I can securely access my account without creating a new password.</li> <li>Admin: As an admin, I want role-based access control, so I can manage store operations while preventing unauthorized actions.</li> </ul>"},{"location":"#payments-and-orders","title":"Payments and Orders","text":"<ul> <li>Authenticated User: As a user, I want to securely pay for items in my cart, so I can complete my purchase.</li> <li>Admin: As an admin, I want to capture order information and manage orders, so I can fulfill customer purchases.</li> </ul>"},{"location":"#22-product-backlog-and-sprint-planning","title":"2.2 Product Backlog and Sprint Planning","text":"<p>Our backlog and sprint planning organize tasks by development priority. Below is the proposed initial backlog:</p> Sprint Feature Priority Description 1 Product Listings High Implement and display product listings. 1 Authentication High Set up NextAuth with Google, Facebook, and GitHub. 2 Admin Panel - CRUD Products High Develop the admin panel for product CRUD operations. 3 Shopping Cart Medium Allow users to add items to a cart and view cart contents. 4 Payment Integration High Implement payment processing using Stripe. 5 Order Management Medium Enable users to view their order history. <p>Diagram: Authentication Flow</p> <pre><code>sequenceDiagram\n    participant User\n    participant App\n    participant NextAuth\n    participant OAuthProvider as \"OAuth (Google, Facebook, GitHub)\"\n\n    User-&gt;&gt;App: Initiates Login\n    App-&gt;&gt;NextAuth: Calls NextAuth API\n    NextAuth-&gt;&gt;OAuthProvider: Redirect to Provider\n    OAuthProvider-&gt;&gt;User: Request Authentication\n    User-&gt;&gt;OAuthProvider: Provide Credentials\n    OAuthProvider-&gt;&gt;NextAuth: Return Token\n    NextAuth-&gt;&gt;App: Authenticate User\n    App-&gt;&gt;User: User Logged In</code></pre>"},{"location":"#3-development-environment-configuration","title":"3. Development Environment Configuration","text":"<p>To maintain code quality and catch issues early, we\u2019ll configure a strict development environment with pre-commit hooks, core dependencies, and structured folder conventions.</p>"},{"location":"#31-pre-commit-hooks-with-husky","title":"3.1 Pre-Commit Hooks with Husky","text":"<p>Utilize Husky for pre-commit hooks, which enforce code quality and formatting standards:</p> <ul> <li>ESLint: For consistent code style and error prevention.</li> <li>Prettier: For formatting standardization.</li> <li>TypeScript: Enforce type checks to avoid type-related errors during development.</li> </ul>"},{"location":"#32-initializing-core-dependencies","title":"3.2 Initializing Core Dependencies","text":"<ol> <li>Install and Configure Next.js Plugins:</li> <li>PWA: Configure PWA capabilities for offline functionality in <code>next.config.js</code>.</li> <li>SEO: Set up basic SEO configuration within <code>_app.js</code> and individual pages.</li> <li>NextAuth.js: Integrate Google, Facebook, and GitHub providers to simplify user login.</li> <li> <p>TRPC: Initialize TRPC for type-safe communication between frontend and backend.</p> </li> <li> <p>Database Setup with Prisma:</p> </li> <li>Define models for <code>User</code>, <code>Product</code>, and <code>Order</code> in <code>prisma/schema.prisma</code>.</li> <li> <p>Use <code>prisma migrate</code> to create tables on Neon.tech during setup.</p> </li> <li> <p>Redux and State Management:</p> </li> <li>Set up Redux Toolkit for state management.</li> <li>Integrate RTK Query with TRPC for streamlined data fetching and state management.</li> </ol> <p>Diagram: Payment Integration Flow</p> <pre><code>sequenceDiagram\n    participant User\n    participant App\n    participant PaymentInterface\n    participant Stripe\n\n    User-&gt;&gt;App: Initiates Checkout\n    App-&gt;&gt;PaymentInterface: Call initPayment\n    PaymentInterface-&gt;&gt;Stripe: Create Payment Intent\n    Stripe-&gt;&gt;PaymentInterface: Return Payment Intent ID\n    PaymentInterface-&gt;&gt;App: Return Payment Intent ID\n    App-&gt;&gt;User: Prompt for Payment Completion\n    User-&gt;&gt;Stripe: Completes Payment\n    Stripe-&gt;&gt;PaymentInterface: Confirm Payment Status\n\n\n    PaymentInterface-&gt;&gt;App: Update Order Status</code></pre>"},{"location":"#33-folder-structure-and-naming-conventions","title":"3.3 Folder Structure and Naming Conventions","text":"<p>Adhere to the following folder structure for maintainability:</p> <ul> <li>Components: Use PascalCase for reusable UI components (e.g., <code>ProductCard.tsx</code>).</li> <li>Pages: Name pages in snake_case for route consistency (e.g., <code>product_details.tsx</code>).</li> <li>Utilities and Hooks: Organize helper functions in <code>lib/</code> and custom hooks in <code>hooks/</code>.</li> </ul>"},{"location":"#conclusion","title":"Conclusion","text":"<p>This document provides a foundational framework for Compustore\u2019s initial development phases, setting up a secure and efficient infrastructure, well-organized repository, and robust CI/CD workflows. Each team member is encouraged to follow these guidelines closely to maintain consistency, code quality, and security as we progress in development.</p> <p>This is a constant todo file. By - @stephane-segning - @Valsuh45 - @Ngha-Boris - @mbunwe-victor - @kouamschekina - @bryandino673 - @ArmandMeppa</p>"},{"location":"SSDLC/","title":"SSDLC Discussions","text":""},{"location":"SSDLC/#project-overview-compustore","title":"Project Overview: Compustore","text":"<p>Project Summary Compustore is a web-based application designed to serve as an online computer store with core e-commerce functionalities. Key features include product listings, order management, secure payment processing, and an admin interface for managing inventory and sales. Built with Next.js, the application will leverage modern technologies like Stripe for payment integration, NextAuth.js for user authentication, and React Admin for efficient administration. The project aims to provide a smooth user experience while adhering to best practices in secure software development. </p> <p>To ensure high-quality development, Compustore will follow a secure software development lifecycle (SSDLC) with steps designed to minimize vulnerabilities from planning through deployment. Adopting Scrum practices, the project will run in iterative sprints, incorporating regular demos and feedback sessions to maintain alignment with business needs. Task management will be organized on a Kanban board, emphasizing collaborative progress tracking.</p> <p>Key Project Objectives - Develop a user-friendly, secure web application for selling computer products. - Implement modular, reusable code components to support efficient scaling and future enhancements. - Ensure cost-effective deployment and operational processes.</p>"},{"location":"SSDLC/#a-requirements","title":"A. Requirements","text":""},{"location":"SSDLC/#functional-requirements","title":"Functional Requirements","text":""},{"location":"SSDLC/#1-store","title":"1. Store","text":"<ul> <li>Product Listings: Enable users to view product listings categorized by various computer hardware and accessory types. Each listing should display essential product details such as name, description, price, specifications, and stock availability.</li> <li>Order Management: Implement functionality for users to add products to a cart, review orders, and complete checkout. The order management system should maintain accurate records of each order, tracking its status (e.g., pending, shipped, delivered).</li> <li>Checkout Functionality: Ensure a secure, smooth checkout process that allows users to review their cart and make payments using integrated Stripe functionality.</li> <li>Invoice Management: Link Stripe invoices and billing systems to each order, allowing users to access transaction records and invoices through their accounts.</li> </ul>"},{"location":"SSDLC/#2-payments","title":"2. Payments","text":"<ul> <li>One-Time and Subscription Payments: Use Stripe to support secure one-time payments for single product purchases and recurring payments for subscription services.</li> <li>Invoice Generation and Management: Ensure that each transaction generates an invoice stored in both the user\u2019s account and the admin interface for tracking and management.</li> <li>Payment Notifications: Configure notifications to confirm successful payments and alert users in case of payment issues.</li> </ul>"},{"location":"SSDLC/#3-user-authentication","title":"3. User Authentication","text":"<ul> <li>Login and Authentication: Utilize NextAuth.js to enable secure user login, registration, and authentication, with session handling managed by Next.js to maintain logged-in status.</li> <li>Session Management: Integrate <code>useSession</code> from NextAuth.js to track user sessions seamlessly across all devices, ensuring a secure and consistent user experience.</li> <li>User Roles: Define roles for users, such as Customer, Admin, and Guest, with varying levels of access to functionality, particularly in the admin panel.</li> </ul>"},{"location":"SSDLC/#4-admin-panel","title":"4. Admin Panel","text":"<ul> <li>CRUD Operations: Build an admin panel using React Admin, allowing for efficient creation, reading, updating, and deletion (CRUD) of products, orders, and invoices.</li> <li>Product and Order Management: Create custom pages within the admin panel for handling product inventory, including the ability to add, edit, and delete products. Implement order management features for tracking order statuses, updating orders, and managing customer queries.</li> <li>Secure Access and Authentication: Configure the admin panel to restrict access to authorized personnel only, leveraging NextAuth.js to verify admin roles before allowing access to any sensitive operations.</li> </ul>"},{"location":"SSDLC/#b-threat-modeling","title":"B. Threat Modeling","text":"<p>Overview Threat modeling for Compustore will identify potential security risks across three user roles (anonymous, user, admin) and within key functionalities such as product management, order processing, and payment handling. The model will use the STRIDE framework to classify threats and evaluate them from both the frontend and backend perspectives. Given that the application will deploy on Vercel and use Neon.tech for production databases, considerations around cloud security, API access, and data protection are essential.</p>"},{"location":"SSDLC/#user-roles-and-threats","title":"User Roles and Threats","text":""},{"location":"SSDLC/#1-anonymous-user-unauthenticated-access","title":"1. Anonymous User (Unauthenticated Access)","text":"<ul> <li>Role Description: This role represents all users who have not logged into the application. Anonymous users should be able to browse products and view individual product details but will not have access to sensitive data or any order history.</li> <li>Potential Threats:<ul> <li>Spoofing and Information Disclosure: Unauthorized access attempts to impersonate a logged-in user, potentially via forged cookies or manipulated session tokens.</li> <li>Tampering: Attempts to modify publicly accessible endpoints to retrieve restricted data (e.g., viewing order history or accessing admin pages).</li> <li>Denial of Service (DoS): Flooding of public endpoints like product listings to overwhelm server capacity.</li> </ul> </li> <li>Mitigations:<ul> <li>Use secure session cookies with HttpOnly and SameSite attributes.</li> <li>Enforce access control by validating user sessions with <code>useSession</code> in NextAuth.js to prevent unauthorized access to logged-in user data.</li> <li>Rate-limit anonymous access to public endpoints to prevent DoS attacks.</li> </ul> </li> </ul>"},{"location":"SSDLC/#2-user-authenticated-customer","title":"2. User (Authenticated Customer)","text":"<ul> <li>Role Description: Authenticated users can browse products, view product details, add products to a cart, and complete purchases. They can also view their own order history but not the order histories of other users.</li> <li>Potential Threats:<ul> <li>Elevation of Privileges: Attempt to escalate privileges by tampering with session tokens or manipulating API requests to gain access to admin-level features.</li> <li>Information Disclosure: Unauthorized access to other users\u2019 order data or sensitive payment information.</li> <li>Repudiation: Users may dispute transactions or claim lack of accountability for certain actions (e.g., unauthorized purchases).</li> </ul> </li> <li>Mitigations:<ul> <li>Implement role-based access controls to restrict order history views to the authenticated user\u2019s own records only.</li> <li>Validate all session tokens with NextAuth.js to prevent token tampering or reuse attacks.</li> <li>Implement logging and monitoring to track user activities, which aids in auditing and repudiation handling.</li> </ul> </li> </ul>"},{"location":"SSDLC/#3-admin-authorized-administrator","title":"3. Admin (Authorized Administrator)","text":"<ul> <li>Role Description: Admins have full access to product and order management, including creating, updating, and deleting products. They can also capture orders and manage the order lifecycle.</li> <li>Potential Threats:<ul> <li>Elevation of Privileges: Unauthorized users gaining admin privileges, possibly through unpatched security vulnerabilities or misconfigurations.</li> <li>Information Disclosure: Accidental exposure of sensitive data, such as product costs, order data, or customer PII, due to admin actions.</li> <li>Tampering and Repudiation: Malicious or accidental modifications of order and product records without proper accountability.</li> </ul> </li> <li>Mitigations:<ul> <li>Require Multi-Factor Authentication (MFA) for admin users to prevent unauthorized access.</li> <li>Enforce strict logging of admin actions for accountability and auditing.</li> <li>Implement role-based access restrictions, ensuring CRUD operations are only accessible to authenticated admin roles.</li> <li>Review and apply the principle of least privilege, ensuring admin accounts are created only as necessary and periodically reviewed.</li> </ul> </li> </ul>"},{"location":"SSDLC/#component-based-threats","title":"Component-Based Threats","text":""},{"location":"SSDLC/#1-product-and-order-management","title":"1. Product and Order Management","text":"<ul> <li>Threats:<ul> <li>Tampering: Unauthorized changes to product data or order statuses via unsecured endpoints.</li> <li>Information Disclosure: Exposing product or order data inadvertently through poorly secured API endpoints.</li> </ul> </li> <li>Mitigations:<ul> <li>Secure CRUD endpoints with role-based access control, allowing only authenticated admin users to perform modifications.</li> <li>Sanitize and validate all data inputs and outputs to prevent injection attacks.</li> </ul> </li> </ul>"},{"location":"SSDLC/#2-payment-processing-and-stripe-integration","title":"2. Payment Processing and Stripe Integration","text":"<ul> <li>Threats:<ul> <li>Spoofing: Attempting to impersonate payment requests or responses between the application and Stripe.</li> <li>Tampering: Modifying payment data in transit to exploit the system, such as changing payment amounts or intercepting invoice data.</li> <li>Information Disclosure: Exposure of sensitive payment data or customer billing information.</li> </ul> </li> <li>Mitigations:<ul> <li>Use HTTPS for all transactions and secure webhooks to prevent data tampering and man-in-the-middle attacks.</li> <li>Only store minimal payment details and rely on Stripe to manage sensitive payment information directly.</li> <li>Implement webhook verification with Stripe to ensure authenticity of incoming payment notifications.</li> </ul> </li> </ul>"},{"location":"SSDLC/#3-authentication-and-session-management","title":"3. Authentication and Session Management","text":"<ul> <li>Threats:<ul> <li>Session Hijacking: Stealing or forging session cookies to gain unauthorized access to accounts.</li> <li>Cross-Site Request Forgery (CSRF): Exploiting the user's logged-in state to perform unauthorized actions on their behalf.</li> <li>Repudiation: Users potentially denying specific actions or purchases made within their session.</li> </ul> </li> <li>Mitigations:<ul> <li>Use secure session cookies with HttpOnly and SameSite attributes to prevent session hijacking.</li> <li>Implement CSRF protection, especially on sensitive actions like account updates and order placements.</li> <li>Log all significant user actions to provide an audit trail for tracking user activity and mitigating repudiation.</li> </ul> </li> </ul>"},{"location":"SSDLC/#4-deployment-and-data-storage-vercel-and-neontech","title":"4. Deployment and Data Storage (Vercel and Neon.tech)","text":"<ul> <li>Threats:<ul> <li>Denial of Service (DoS): Overloading the production server or database, leading to downtime or performance issues.</li> <li>Data Breaches: Unauthorized access to the database, potentially exposing user data and order information.</li> </ul> </li> <li>Mitigations:<ul> <li>Use Vercel\u2019s security features and Neon.tech\u2019s built-in security configurations, including access control and network restrictions, to protect against unauthorized access.</li> <li>Enable automated backups in Neon.tech and implement secure database credentials management via Vercel\u2019s environment variables.</li> <li>Monitor server and database access logs and set up alerts for unusual access patterns or potential DoS attacks.</li> </ul> </li> </ul>"},{"location":"SSDLC/#c-architecture-tech-stack","title":"C. Architecture &amp; Tech Stack","text":""},{"location":"SSDLC/#application-architecture","title":"Application Architecture","text":"<p>The Compustore application will be built on a microservices-inspired architecture using Next.js as the main framework, with separation between frontend and backend services. We\u2019ll implement a modular structure where each component is decoupled, making the system flexible, scalable, and adaptable to future integrations. The architecture is designed for rapid development while maintaining a high degree of security and maintainability through static code analysis (SCA) and comprehensive test coverage.</p>"},{"location":"SSDLC/#deployment-and-hosting","title":"Deployment and Hosting","text":"<ul> <li>Frontend and Backend Deployment: Vercel will host the Next.js application, which handles both frontend and backend API routes. The app will leverage Vercel\u2019s edge functions for faster performance and secure, scalable deployment.</li> <li>Database: Neon.tech will provide the PostgreSQL database in production, optimized for scalability and low latency. Prisma ORM will be used for seamless communication between the application backend and Neon.tech, simplifying database operations with TypeScript type safety.</li> </ul>"},{"location":"SSDLC/#key-technologies-and-tools","title":"Key Technologies and Tools","text":""},{"location":"SSDLC/#1-core-framework-and-libraries","title":"1. Core Framework and Libraries","text":"<ul> <li>Next.js: The primary framework for frontend and backend development, leveraging both the <code>src</code> and <code>app</code> directories. Next.js will handle server-side rendering (SSR) and static site generation (SSG) to optimize load times and SEO.<ul> <li>Next.js Plugins:</li> <li>PWA: Enable Progressive Web App (PWA) capabilities for offline support and installation on mobile devices.</li> <li>SEO: Leverage Next.js SEO plugins to optimize pages with meta tags, structured data, and social sharing configurations.</li> <li>NextAuth.js: Manage authentication via OAuth for Google, Facebook, and GitHub, focusing on security and ease of use. No username/password authentication will be implemented to reduce risk and simplify maintenance.</li> <li>i18next: Implement internationalization to support multi-language experiences, making the application accessible to a broader audience.</li> <li>Next-Redux-Wrapper: For seamless integration of Redux with Next.js, ensuring that state is managed consistently across SSR/SSG pages.</li> <li>TRPC (Type-safe Remote Procedure Calls): Facilitate type-safe communication between the frontend and backend, allowing us to leverage TypeScript for shared types and safer API calls.</li> <li>Prisma: ORM to manage database communication with Neon.tech. Prisma enables efficient database querying, type-safe operations, and migration management in TypeScript.</li> </ul> </li> </ul>"},{"location":"SSDLC/#2-state-management-and-data-fetching","title":"2. State Management and Data Fetching","text":"<ul> <li>Redux and Redux Toolkit: Core state management, utilizing the <code>redux-toolkit</code> for building and managing the application state. The toolkit offers a streamlined setup for reducers and middleware, with built-in dev tools and support for enhanced state immutability.</li> <li>RTK Query + TRPC: Combined with Redux Toolkit and TRPC, RTK Query will enable caching and data synchronization with backend APIs, offering enhanced control over data fetching and mutation while minimizing boilerplate code.</li> <li>Logging: Integrate logging middleware (e.g., Redux Logger or custom middleware) for debugging and error tracking during development. Error logging in production will be managed by a logging service such as Sentry.</li> </ul>"},{"location":"SSDLC/#3-authentication","title":"3. Authentication","text":"<ul> <li>NextAuth.js: Third-party authentication integration with providers like Google, Facebook, and GitHub using OAuth, configured to prevent vulnerabilities like session hijacking and token tampering. Session management will be handled with <code>useSession</code>, providing secure, encrypted tokens for client-server communication.</li> </ul>"},{"location":"SSDLC/#4-payment-integration-interface","title":"4. Payment Integration Interface","text":"<ul> <li>Abstract Payment Interface: Create an interface for payment integration with modular functions that allow switching payment providers with minimal changes. </li> <li>Common Payment Functions:<ul> <li><code>initPayment</code>: Initialize the chosen third-party payment provider (e.g., Stripe) to set up the payment session.</li> <li><code>editPaymentData</code>: Update payment details in the third-party provider (e.g., modifying Stripe payment intent).</li> <li><code>getPaymentStatus</code>: Fetch the status of a transaction (e.g., Stripe payment intent status).</li> <li><code>cancelPayment</code>: Optionally, support canceling the payment if the user abandons the transaction.</li> </ul> </li> <li>Stripe Implementation: Initially, implement this interface with Stripe as the payment provider, allowing easy swapping for future providers.</li> </ul>"},{"location":"SSDLC/#5-static-code-analysis-sca-and-code-quality","title":"5. Static Code Analysis (SCA) and Code Quality","text":"<ul> <li>Husky: Set up pre-commit hooks using Husky to enforce code quality checks, including:<ul> <li>ESLint: Linting for consistent code styling and potential error prevention.</li> <li>Prettier: Code formatting for a clean and consistent style.</li> <li>TypeScript: All code will use TypeScript (no <code>.js</code> files), enforcing strict type-checking to catch potential errors and improve code quality.</li> </ul> </li> <li>SonarLint: Code analysis to identify potential security vulnerabilities and code smells. SonarLint will integrate directly with the development environment for real-time feedback.</li> <li>Dependabot: Regular dependency scanning and updates to ensure third-party packages are up-to-date, minimizing the risk of security vulnerabilities in dependencies.</li> </ul>"},{"location":"SSDLC/#6-uiux-development","title":"6. UI/UX Development","text":"<ul> <li>TailwindCSS: A utility-first CSS framework for building responsive, modern UIs quickly.</li> <li>Flowbite: Provides a library of UI components compatible with TailwindCSS, accelerating the development of consistent and visually appealing elements.</li> <li>Storybook: Component-driven UI development tool, allowing us to document and test components in isolation. Storybook also improves UI consistency and speeds up testing and bug-fixing.</li> </ul>"},{"location":"SSDLC/#7-testing-and-performance","title":"7. Testing and Performance","text":"<ul> <li>Playwright: For end-to-end testing to verify that all user journeys and flows function as expected across different browsers.</li> <li>Artillery: Load and performance testing to identify bottlenecks, helping ensure the app performs well under high-traffic conditions.</li> </ul>"},{"location":"SSDLC/#8-package-management-and-cicd","title":"8. Package Management and CI/CD","text":"<ul> <li>Yarn: Preferred package manager for faster and more consistent dependency management.</li> <li>GitHub Actions (CI/CD Pipeline): Automated CI/CD pipeline configured to:<ul> <li>Run tests and static code analysis on each pull request.</li> <li>Deploy automatically to Vercel\u2019s preview environment for staging and testing.</li> <li>Perform vulnerability checks on dependencies.</li> </ul> </li> <li>Dependabot: Integrated into the CI/CD pipeline to monitor dependencies for vulnerabilities and initiate pull requests for updates.</li> </ul>"},{"location":"SSDLC/#9-development-environment-configuration","title":"9. Development Environment Configuration","text":"<ul> <li>Pre-configured VSCode and IntelliJ: Project-level settings to streamline developer environments, with recommended extensions and settings files for ESLint, Prettier, and TypeScript.</li> <li>Environment Variables: Use Vercel\u2019s environment management for sensitive data like API keys, Stripe keys, and database credentials, ensuring that secrets are not exposed in the codebase.</li> </ul>"},{"location":"architecture/","title":"Stripe Integration Demo Project","text":""},{"location":"architecture/#project-overview","title":"Project Overview","text":"<p>The Stripe Integration Demo Project is a hands-on initiative designed to enhance the team\u2019s expertise in Stripe's API and infrastructure. By building a full-stack application from scratch, the team aims to deepen their understanding of both the front-end and back-end components of Stripe-based systems. This project will also act as a foundational platform for the upcoming Payment Processor Project, which will be developed for commercial use.</p>"},{"location":"architecture/#key-objectives","title":"Key Objectives:","text":"<p>Build a full-stack demo application with Stripe integration using Next.js. Develop a comprehensive understanding of the technologies involved in Stripe projects, such as payment processing, subscriptions, and invoice management. Prepare for future Stripe projects by mastering relevant concepts and components.</p>"},{"location":"architecture/#project-goals","title":"Project Goals","text":"<p>Technical Proficiency: At the end of the project, each team member should be able to explain the technologies implemented, including the following components:</p> <p>Front-end and back-end integration using Next.js. Database management and TypeORM. Stripe's payment processing and subscription management functionalities. End-to-End Functionality: Implement a working end-to-end (E2E) application that demonstrates a complete Stripe workflow, including:</p> <p>A Store with payment options. One-time and subscription-based payments. Invoice and subscription management. Deployment and Maintenance: Develop strategies for deployment and ongoing maintenance of the application.</p>"},{"location":"architecture/#tech-stack","title":"Tech Stack","text":"<p>The project will leverage the following technologies:</p> <p>Next.js: Chosen for both front-end and back-end development due to its popularity and recent adoption in Stripe projects. React: For building responsive and interactive user interfaces. Express: For handling server-side logic. TypeORM: For database management and modeling. NextAuth.js: To manage authentication, with custom configuration for compatibility with our backend. Other Libraries: Abstract classes, plugins, and third-party resources as needed. Timeline and Milestones The estimated project duration is 8 to 10 weeks. Key milestones include:</p> <p>Project Setup &amp; Initial Development (Weeks 1-2): Establish the tech stack and create the initial project framework. Store &amp; Payment Features (Weeks 3-6): Develop the store functionality, including one-time and subscription payments. Invoice &amp; Subscription Management (Weeks 6-8): Implement invoice management and subscription handling. Testing &amp; Review (Week 9): Conduct extensive testing, review sequence diagrams, and make necessary adjustments. Deployment &amp; Maintenance Strategy (Week 10): Prepare for deployment and finalize the project documentation. Features and Requirements The application will include the following key features:</p>"},{"location":"architecture/#store","title":"Store:","text":"<p>Product listings, order management, and checkout functionality. Payments:</p> <p>Support for one-time and subscription payments through Stripe. Invoice Management:</p> <p>Integration with Stripe for managing invoices and billing. Authentication:</p> <p>User login and authentication using NextAuth.js. Session management to identify logged-in users using the useSession hook.</p>"},{"location":"architecture/#admin-panel","title":"Admin Panel:","text":"<p>Using React Admin (RA) to handle CRUD operations for products and orders. Custom pages for product and order management. Configurations to ensure backend connectivity and secure authentication. Technical Considerations Abstract Classes and Plugins: We will utilize abstract classes and plugins for code reusability and modularity. Progressive Web App (PWA): Research has been conducted on how to implement PWA features, including triggering installations.</p>"},{"location":"architecture/#development-methodology","title":"Development Methodology","text":"<p>For this demo project, we are following a collaborative workflow to ensure consistent progress. Additionally:</p> <p>Scrum Framework: We will implement Scrum practices, including a monthly Spring Demo to present progress and gather feedback. Kanban Board: To track tasks and maintain progress transparency. Managed by @Stephane Segning Lambou and @Armand Meppa.</p>"},{"location":"architecture/#diagrams-and-visual-documentation","title":"Diagrams and Visual Documentation","text":"<p>To aid in understanding and clarity, we will be creating and reviewing the following diagrams:</p> <p>Project Overview Diagram: Visual representation of the overall project structure and workflows.  </p> <p>UML Sequence Diagrams: Detailed sequence diagrams for critical components, such as \"Subscribe to Product License\" and \"Manage Subscriptions.\" <pre><code>sequenceDiagram\n    title Full test search\n \u00a0\u00a0 actor User\n \u00a0\u00a0 User-&gt;&gt;Frontend: SearchProduct(text)\n \u00a0\u00a0 Frontend-&gt;&gt;Backend: searchProduct(text)\n \u00a0\u00a0 Backend-&gt;&gt;DB: Search full text\n \u00a0\u00a0 DB--&gt;&gt;Backend: hits\n \u00a0\u00a0 Backend--&gt;&gt;Frontend: Hits</code></pre> <pre><code>sequenceDiagram\n    title See product discription\n \u00a0\u00a0 actor User\n \u00a0\u00a0 User-&gt;&gt;Frontend: See a product description\n \u00a0\u00a0 Frontend-&gt;&gt;Backend: getProduct(id)\n \u00a0\u00a0 Backend-&gt;&gt;DB: findById(id)\n \u00a0\u00a0 DB--&gt;&gt;Backend: product\n \u00a0\u00a0 Backend--&gt;&gt;Frontend: product\n \u00a0\u00a0 Frontend-&gt;&gt;Frontend: Display the product</code></pre> <pre><code>sequenceDiagram\n \u00a0\u00a0 title Add to cart\n \u00a0\u00a0 actor User\n \u00a0\u00a0 User-&gt;&gt;Frontend: Add product to cart\n \u00a0\u00a0 Frontend-&gt;&gt;Backend: addProductToCart(productId)\n \u00a0\u00a0 Backend-&gt;&gt;Backend: getAssociatedCart() # Get cart associated with user\n \u00a0\u00a0 Backend-&gt;&gt;Backend: addProductToCart(cartId, productId)\n \u00a0\u00a0 Backend--&gt;&gt;Frontend: card</code></pre> <pre><code>sequenceDiagram\n \u00a0\u00a0 title Download digital product\n \u00a0\u00a0 actor User\n \u00a0\u00a0 User-&gt;&gt;Frontend: Download a product with id\n \u00a0\u00a0 Frontend-&gt;&gt;Backend: getDownloadProductLink(productId) # Secure this link\n \u00a0\u00a0 Backend-&gt;&gt;Backend: Logic to get the download link of a product for user\n \u00a0\u00a0 alt External object for links\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend-&gt;&gt;DB: Read product and get product-download link\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DB--&gt;&gt;Backend: link\n \u00a0\u00a0 else\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend-&gt;&gt;DB: Read product and get link from product attribute\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 BD--&gt;&gt;Backend: product\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend--&gt;&gt;Backend: extract link\n \u00a0\u00a0 end\n \u00a0\u00a0 Backend--&gt;&gt;Frontend: link # https://cdn.gis-stripe.cm/download/products/678-23-24324-2343.png\n \u00a0\u00a0 Frontend-&gt;&gt;Web: open link</code></pre> <pre><code>sequenceDiagram\n \u00a0\u00a0 title Buy a product\n \u00a0\u00a0 actor User\n \u00a0\u00a0 User-&gt;&gt;Frontend: Buy a cart\n \u00a0\u00a0 Frontend-&gt;&gt;Backend: createOrGetCheckoutSession(cartId)\n \u00a0\u00a0 Backend--&gt;&gt;Frontend: checkoutSession\n\n \u00a0\u00a0 opt Update user contact info\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Frontend-&gt;&gt;Frontend: info input\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Frontend-&gt;&gt;Backend: updateContactInfo\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend-&gt;&gt;DB: persist checkoutSession\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DB--&gt;&gt;Backend: ok\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend--&gt;&gt;Frontend: checkoutSession\n \u00a0\u00a0 end\n\n \u00a0\u00a0 opt Update user address info\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Frontend-&gt;&gt;Frontend: info input\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Frontend-&gt;&gt;Backend: updateAddressInfo\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend-&gt;&gt;Backend: Validate address data\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend-&gt;&gt;DB: persist checkoutSession\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DB--&gt;&gt;Backend: ok\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend--&gt;&gt;Frontend: checkoutSession\n \u00a0\u00a0 end\n\n \u00a0\u00a0 opt Update user payment info\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Frontend-&gt;&gt;Frontend: info input\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Frontend-&gt;&gt;Backend: updatePaymentInfo\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend-&gt;&gt;Backend: Validate payment info\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend-&gt;&gt;PaymentProcessor: Create payment intent\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 PaymentProcessor--&gt;&gt;Backend: intent\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend-&gt;&gt;Backend: Create price estimate\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend-&gt;&gt;DB: persist checkoutSession\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 DB--&gt;&gt;Backend: ok\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Backend--&gt;&gt;Frontend: checkoutSession\n \u00a0\u00a0 end\n\n \u00a0\u00a0 Frontend-&gt;&gt;Frontend: use checkoutSession to proceed to payment\n\n \u00a0\u00a0 opt Confirm on the backend side\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Frontend-&gt;&gt;Backend: Confirm checkout\n \u00a0\u00a0 end\n\n \u00a0\u00a0 Frontend-&gt;&gt;Frontend: Show ok page</code></pre> <pre><code>sequenceDiagram\ntitle Subscribe to a product license\nactor User\nUser -&gt;&gt; Client: Selects Product License\nClient -&gt;&gt; Server: Send Subscription Request\nServer -&gt;&gt; Server: Validate Subscription Request\nServer -&gt;&gt; Payment : Initiate Payment\nPayment --&gt;&gt; Server: Payment Confirmation\nServer -&gt;&gt; DB: Save Subscription and Payment Details\nServer --&gt;&gt; Client: Subscription Success with License\nClient --&gt;&gt; User: Display Subscription Confirmation</code></pre> <pre><code>sequenceDiagram\ntitle Manage subscription\nCustomer -&gt;&gt; WebApp: Request to change plan or update payment method\nWebApp -&gt;&gt; Payment Processor: Update subscription or payment method\nPayment Processor -&gt;&gt; Backend: customer.subscription.updated OR invoice.payment_succeeded\nBackend -&gt;&gt; Database: Save updated plan details (e.g., new plan ID, billing cycle)\nBackend --&gt;&gt; WebApp: Notify about subscription update status\nWebApp --&gt;&gt; Customer: Confirmation of subscription update\nCustomer -&gt;&gt; WebApp: Request to cancel subscription\nWebApp -&gt;&gt; Payment Processor: Cancel subscription (immediate or end of billing period)\nPayment Processor -&gt;&gt; Backend: customer.subscription.deleted\nBackend -&gt;&gt; Database: Update subscription status to \"canceled\"\nBackend --&gt;&gt; WebApp: Notify about subscription cancellation\nWebApp --&gt;&gt; Customer: Confirmation of subscription cancellation</code></pre> </p>"},{"location":"architecture/#research-additional-tools","title":"Research &amp; Additional Tools","text":"<p>React Admin (RA):</p> <p>Setup: Establish connection with the backend and authentication using NextAuth.js. Configuration: Simple, with pages for orders and products. Customization: Advanced, focusing on theme customization and additional features. NextAuth.js: Custom configuration for authentication, including handling sessions to retrieve logged-in clients.</p> <p>No-Code Technologies: @Stephane Segning Lambou presented on no-code technologies, exploring their potential for future projects.</p> <p>Design Tools: We had an introductory session on Figma for UI design exploration and basic prototype handling.</p>"},{"location":"architecture/#deep-dive","title":"Deep dive","text":"<ul> <li>Tailwindcss</li> <li>Lodash</li> <li>Nextjs</li> <li>Jestjs</li> <li>i18next</li> <li>Zod</li> <li>Formik</li> <li>Typeorm</li> <li>tRPC</li> <li>creatContext</li> </ul>"},{"location":"architecture/#pending-topics","title":"Pending Topics","text":"<p>Project Name: The name for this project is still to be decided. Deployment Models and Maintenance: Final decisions on deployment and long-term maintenance are yet to be made.</p>"},{"location":"branching-strategy/","title":"Branching Strategy","text":""},{"location":"branching-strategy/#branch-types","title":"Branch types","text":"<ol> <li>Main Branch (Main/Production) </li> <li>Contains stable, release-ready code. Only merges from the <code>release</code> branch should go directly into <code>main</code>.</li> <li> <p>Protected branch requiring approvals and automated checks.</p> </li> <li> <p>Development Branch (Develop) </p> </li> <li>Integration branch where all feature branches merge before deployment to staging.</li> <li> <p>Used for continuous testing and quality assurance.</p> </li> <li> <p>Feature Branches (<code>feature/[feature-name]</code>) </p> </li> <li>Created for each specific feature or enhancement (e.g., <code>feature/product-listing</code>, <code>feature/user-authentication</code>).</li> <li> <p>Feature branches should be short-lived and merged back to <code>develop</code> upon completion.</p> </li> <li> <p>Release Branches (<code>release/[release-version]</code>) </p> </li> <li>Created when preparing for a release cycle, typically from the <code>develop</code> branch.</li> <li>Allows final bug fixes and quality checks before merging into <code>main</code>.</li> <li> <p>After release, merge back to both <code>main</code> and <code>develop</code>.</p> </li> <li> <p>Hotfix Branches (<code>hotfix/[issue-id]</code>) </p> </li> <li>Used to address urgent issues or bugs found in production.</li> <li>Branched from <code>main</code> and merged back to both <code>main</code> and <code>develop</code> once resolved.</li> </ol>"}]}